
                      ===  68. AS VÁRIAS MANEIRAS DE DECLARAR FUNÇÕES EM JAVASCRIPT  ===


---> As funções são first-class objects (objetos de primeira classe);
Obs: todas as funções são tratadas como objetos de primeira classe;


==> 1ª maneira de declarar funções:

function falaOi() {
   console.log('oi');
};

::: Criando uma função dessa maneira e apenas desta maneira, ocorre o "function hoisting";

::: Que é o comportamento padrão do JavaScript de mover as declarações de funções para o topo do seu escopo antes da execução do código, não importa se o escopo seja global ou local;

::: Com o function hoisting é possível chamar funções antes mesmo das linhas em que elas estão escritas;



==> 2ª maneira de declarar funções:

::: Podemos tratar as funções também como um dado, é chamado de Function expression, exemplo:

const souUmDado = function() {
   console.log('Sou um dado'); 
};



==> 3ª maneira de declarar funções:

const funcaoArrow = () => {
   console.log('Sou uma arrow function');
};

::: As arrow functions são uma function expression, só que mais curta;

::: As arrow function se diferenciam das demais funções quando se utiliza a palavra "This";



==> 4ª maneira de declarar funções:

const objeto = {
   falar: function() {
      console.log('Sou uma função em um objeto...');
   }
};

--------- Ou ----------

const objeto = {
    falar() {
        console.log('Sou uma função em um objeto...');
    }
};

::: Dentro de objetos é possível declarar variáveis, e chama-lá usando a notação de ponto. Exemplo;
• objeto.falar();

::: Desta maneira acima, estamos chamando a função de dentro do objeto



                                                   ===  69. PARÂMETROS DA FUNÇÃO  ===


::: Se em uma chamada de função for enviado algum parametro para a função, mas na função não existir nenhum parâmetro para receber;

::: Os parâmetros enviados serão guardados em uma variável chamada "arguments", os parâmetros serão guardados em forma de array, então para chamados basta colocar o índice depois da variavel, exemplo:
• arguments[3]

::: Essa possibilidade só funciona para as funções que realmente começam com a palavra "function". 
Não funciona para Arrow Functions;


---> Exemplo de função sem parâmetros recebendo parâmetros:

function minhaFuncao() {
    console.log(arguments[1]);
};

minhaFuncao('Valor', 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);



---> Exemplo de iteração com a variável "arguments":
::: É possível iterar sobre a variável "arguments";

function minhaFuncao() {
    let soma = 0;

    for (let argumento of arguments) {
        soma += argumento;
    }

    console.log(soma);
}

minhaFuncao(1, 2, 3, 4, 5);
::: Resultado será 15;


---> O rest operator (...) pode substituir a variável arguments em uma função, e funciona para qualquer tipo de função, seja ela normal ou arrow.



                                                           ===  71. ESCOPO LÉXICO  ===


Escopo léxico basicamente é um reconhecimento que sua função faz primeiramente dentro dela e depois nos escopos "pais", por último sendo o escopo global.


Mais sobre => https://www.treinaweb.com.br/blog/contexto-e-escopo-no-javascript
Mais sobre => https://devolopingtheworld.hashnode.dev/roadmap-backend-8-escopo-lexico



                                                             ===  72. CLOSURES  ===


::: Uma closure é a combinação de uma função com as referências ao estado que a circunda (o ambiente léxico). 

::: Em outras palavras, uma closure lhe dá acesso ao escopo de uma função externa a partir de uma função interna. 

::: Em JavaScript, as closures são criadas toda vez que uma função é criada, no momento da criação da função.


Mais detalhes => https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Closures



                                                       ===  73. FUNÇÕES DE CALLBACK  ===


::: Uma função callback é uma função passada a outra função como argumento, que é então invocado dentro da função externa para completar algum tipo de rotina ou ação.

==>Aqui está um pequeno exemplo:

function saudacoes(name) {
    alert("Olá " + name);
}

function processUserInput(callback) {
    var name = prompt("Por favor insira seu nome.");
    callback(name);
}

processUserInput(saudacoes);


Mais detalhes => https://www.freecodecamp.org/portuguese/news/funcoes-de-callback-em-javascript-o-que-sao-e-como-usa-las/



                                                     ===  74. FUNÇÕES IMEDIATAS (IIFE)  ===


::: IIFE -> Imemediately invoked function expression;

::: É uma função em JavaScript que é executada assim que definida.

::: É um Design Pattern também conhecido como "Self-Executing Anonymous Function" e contém duas partes principais. 


---> A primeira é a função anônima cujo escopo léxico é encapsulado entre parênteses.

::: Isso previne o acesso externo às variáveis declaradas na IIFE, bem como evita que estas variáveis locais poluam o escopo global.

---> A segunda parte corresponde à criação da expressão ()

:::  Por meio da qual o interpretador JavaScript avaliará e executará a função.



==> Exemplo:
::: A função se torna uma expressão que é imediatamente executada. A variável definida dentro da expressão não pode ser acessada fora de seu escopo.

(function () {
    var nome = "Felipe";  // A variável nome não é acessível fora do escopo da expressão
}) ();

console.log(nome);  // gerará o erro "Uncaught ReferenceError: nome is not defined"


Mais detalhes => https://developer.mozilla.org/pt-BR/docs/Glossary/IIFE



                                      ===  75. FUNÇÕES FÁBRICA (FACTORY FUNCTIONS)  ===


As Factorys functions é uma função que retorna um objeto, é uma técnica que permite criar objetos de forma eficiente e flexível, tornando o código mais organizado e fácil de manter.



==> Getter
::: O getter, com a sintaxe get é associado a uma função que será chamada quando a propriedade em questão for acessada e solicitada de forma dinâmica.

::: É possível utilizá-la para retornar o status de uma variável interna, sem utilizar métodos de forma explícita.


Exemplo:

class Curso {
    constructor(materia, professor, duracao){
        this.materia = materia,
        this.professor = professor,
        this.duracao = duracao
    }
    get prof() {
        return this.professor
    }
}

let poo = new Curso('Programação orientada a objetos', 'Rafaella', '1 semestre')
console.log(poo.prof) //Rafaella



==> Setter
::: Geralmente usados junto com os getters, os setters são utilizados para definirem valores para uma propriedade específica.


Exemplo:

class Aluno {
    constructor(nome, curso, semestre){
        this.nome = nome,
        this.curso = curso,
        this.semestre = semestre
    }
    set nomeAluno(nomeAluno) {
        this.nome = nomeAluno
    }
}

let lucas = new Aluno('', 'Engenharia', 5)
lucas.nomeAluno = 'Lucas'
console.log(lucas.nome) //Lucas



==> Artigos e documentações:

Mais detalhes (Factory functions) =>
https://devpleno.com/factory-function
https://medium.com/@viniazvd/classes-vs-fun%C3%A7%C3%B5es-construtoras-vs-fun%C3%A7%C3%B5es-f%C3%A1brica-b92a6afa70a4

Mais detalhes (Getter, Setter, This, Class) => 
https://www.alura.com.br/artigos/as-classes-no-javascript

Mais detalhes (Getter) => 
https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Functions/get

Mais detalhes (Setter) => 
https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Functions/set



                                      ===  76. PRATICANDO COM FACTORY FUNCTIONS  ===


Notas da aula :

==> Minutos 21:00 á 25:00:

::: Quem chama a função, passa a ser o "this";

::: Para mudar o this padrão, para o this que você está utilizando, basta utilizar o comando (depois das chaves da função desejada)  " .bind(this) ". 
::: Depois desse comando, básicamente é como se estivesse falando para a função, " Olhá, ao invés de utilizar o seu this, use o meu this. "

::: Todas as funções tem vários comandos para se utilizar depois delas;

::: Arrow functions não mudam o compartamento do this, ou seja, se utilizar uma arrow function ao invés de um function normal, o this utilizado continuará sendo o seu.



---> função eval()

Aviso: executar JavaScript a partir de uma string é um enorme risco de segurança. É muito fácil para um malfeitor executar código arbitrário quando você usa o eval().

::: A função eval() avalia o código JavaScript representado como uma string e retorna seu valor de conclusão. A fonte é analisada como um script.


exemplo:

console.log(eval('2 + 2'));
// Expected output: 4

console.log(eval(new String('2 + 2')));
// Expected output: 2 + 2

console.log(eval('2 + 2') === eval('4'));
// Expected output: true

console.log(eval('2 + 2') === eval(new String('2 + 2')));
// Expected output: false


Mais detalhes =>
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_direct_eval!



                           ===  77. FUNÇÕES CONSTRUTORAS (CONSTRUCTOR FUNCTIONS)  ===


=






















